%% calculate engagement

% quantile normalize
for i = 1:3, X.pep.eq(:,:,i) = quantilenorm(X.pep.e(:,:,i)); end


% get unique identifiers (cell line name, project Achilles ID) for each cell line
[u,col] = unique(X.line.name);
ach_id = X.line.DepMap_ID(col);
lin = X.line.lineage(col);

% pre-allocate memory
qnt = nan(height(X.pep.e),length(u),3);
cc = nan(height(X.pep.a),length(u),3);

% calculate cv across replicates for all cell lines
for i = 1:length(u)
    cols = strcmp(X.line.name,u(i));    
    dat = X.pep.eq(:,cols,:);
    cc(:,i,:) = std(dat,0,2,'omitnan')./mean(dat,2,'omitnan');    
end
    
% use cv to filter out noisy measurements, calculate median engagement
% ... for each cell line
for i = 1:length(u)        

    % get replicates
    dat = X.pep.eq(:,strcmp(X.line.name,u(i)),:);

    % take median
    m = median(dat,2,'omitnan');

    % don't retain noisy values or peptides which were only detected once
    m(sum(~isnan(dat),2) < 2 | cc(:,i,:) > 0.1) = NaN;
    qnt(:,i,:) = m;
end

% re-scale
qnt = 200*(qnt - 0.5);

%% find heterogeneous cysteines

bch = X.line.batch(col); bch = split(bch,'_'); bch = bch(:,1); ubch = unique(bch);
ubch = unique(bch);
ach_id = X.line.DepMap_ID(col);
fld = ["KB05","KB03","KB02"];
for i = 1:3, D.diff.(fld(i)) = []; D.std.(fld(i)) = []; end


for j = 1:3
for i = 1:length(ubch)
    dat = qnt(:,strcmp(bch,ubch(i)),j);
    if sl(dat) > 2       
        D.std.(fld(j)) = [D.std.(fld(j)),std(dat,0,2,'omitnan')];
        for k = 1:sl(dat)
            d2 = dat(:,k) - median(dat,2,'omitnan');
            D.diff.(fld(j)) = [D.diff.(fld(j)),d2];
        end
    end
end
end


[lin2, bch2, nm2,ach2] = deal([]);
clear j;
for i = 1:length(ubch)
    dat = qnt(:,strcmp(bch,ubch(i)),2);
    lns = lin(strcmp(bch,ubch(i)));
    bchs = bch(strcmp(bch,ubch(i)));
    nms = u(strcmp(bch,ubch(i)));
    achh = ach_id(strcmp(bch,ubch(i)));
    if sl(dat) > 2       
        for k = 1:sl(dat)
            lin2 = [lin2;lns(k)];
            bch2 = [bch2;bchs(k)];
            nm2 = [nm2;nms(k)];
            ach2 = [ach2;achh(k)];
        end
    end
end
D.line.lineage = lin2; D.line.batch = bch2; D.line.name = nm2; D.line.DepMap_ID = ach2;

for i = 1:3, D.std.(fld(i))(D.std.(fld(i)) == 0) = NaN; end

for i = 1:3, D.nnz.(fld(i)) = sum(D.std.(fld(i)) >= 10,2,'omitnan'); end
for i = 1:3, D.rank.(fld(i)) = 1 - tiedrank(D.nnz.(fld(i)))/length(find(~isnan(D.nnz.(fld(i))))); end

for i = 1:3, D.globalstd.(fld(i)) = std(qnt(:,:,i),0,2,'omitnan'); D.globalstd.(fld(i))(D.globalstd.(fld(i)) == 0) = NaN; end
for i = 1:3, D.globalrank.(fld(i)) = 1 - tiedrank(D.globalstd.(fld(i)))/length(find(~isnan(D.globalstd.(fld(i))))); end

for i = 1:3, D.det.(fld(i)) = sum(~isnan(qnt(:,:,i)),2)./sl(qnt); end

m = median(qnt(:,:,2),2,'omitnan');
row = D.rank.KB03 < 0.05 & D.globalrank.KB03 < 0.05 & D.det.KB03 >= 0.5;

%% find terms which are enriched among heterogeneous cysteines
% recall that, since CSEA is a stochastic algorithm, p-value estimates will not reproduce exactly across runs
C = load(in + "CSEA.repository.mat"); C = C.X;


r = find(contains(C.set.type,"molecular")|contains(C.set.name,"zhang_et"));
a1 = find(row);
acn = []; for i = 1:height(a1), s = split(X.pep.acc_cys(a1(i)),';'); s = s(~cellfun(@isempty,s)); acn = unique([acn;unique(s)]); end


fake = setdiff(find(D.rank.KB03 > 0.25 & D.globalrank.KB03 > 0.25 & D.det.KB03 >= 0.5),a1);
% fake = setdiff(find(D.det.KB03 >= 0.5),a1);
acf = []; for i = 1:height(fake), s = split(X.pep.acc_cys(i),';'); s = s(~cellfun(@isempty,s)); acf = unique([acf;unique(s)]); end

res = csea(acf,acn,100,C.set.name(r),C.set.cys(r));
res = sortrows(res,2,"ascend");

clf
x = fliplr(1:height(res));
y = -log10(res.("FDR"));
scatter(x,y,20,'k','filled');
f = find(contains(res.("set name"),"zhang") & y > 10);
hold on
scatter(x(f),y(f),20,[1,0,0],"filled","markeredgecolor",[1,1,0])
ff('signatures',"-log_{10}(FDR)",'',12,'tex','out')
set(gca,"ytick",[0:20:180])
axis tight
ylim([0,180])
set(gca,'xtick',[0:25:175]);xtickangle(45)
xlim([-1,175])
set(gca,'ticklength',[0.025,0.025]);
